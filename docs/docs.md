---
title: Operations
nav_order: 2
---
{::options toc_levels="1..3" /}

# LLHD Operations
{: .no_toc}

* TOC
{:toc}

<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `llhd.add` (llhd::AddOp)

Add two values.

Syntax:

```
operation ::= `llhd.add` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.add(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
|         |             |  |  |  |  |  |  |  | `lhs` | integer |  |  |  |  |  |  |  |  |  |
|         |             |  |  |  |  |  |  |  | `rhs` | integer |  |  |  |  |  |  |  |  |  |

#### Results:

| Result | Description |
| :----: | ----------- |
|        |             |  |  |  |  |  |  |  |  | &laquo;unnamed&raquo; | integer |  |  |  |  |  |  |  |  |  |  |

### `llhd.and` (llhd::AndOp)

Bitwise AND

Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise AND. The
result is always of the exact same type as the two inputs.

**Syntax:**
```
and-op ::= ssa-id `=` `llhd.and` ssa-lhs `,` ssa-rhs attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.and %0, %0 : i32
```

**Truth Table for `iN`:**

| `and` |   0   |   1   |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   1   |   0   |   1   |

**Truth Table for `lN`:**

| `and` |   U   |   X   |   0   |   1   |   Z   |   W   |   L   |   H   |   -   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   U   |   U   |   U   |   0   |   U   |   U   |   U   |   0   |   U   |   U   |
|   X   |   U   |   X   |   0   |   X   |   X   |   X   |   0   |   X   |   X   |
|   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |
|   1   |   U   |   X   |   0   |   1   |   X   |   X   |   0   |   1   |   X   |
|   Z   |   U   |   X   |   0   |   X   |   X   |   X   |   0   |   X   |   X   |
|   W   |   U   |   X   |   0   |   X   |   X   |   X   |   0   |   X   |   X   |
|   L   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |
|   H   |   U   |   X   |   0   |   1   |   X   |   X   |   0   |   1   |   X   |
|   -   |   U   |   X   |   0   |   X   |   X   |   X   |   0   |   X   |   X   |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
|         |             | `lhs` | integer or integer |  |  |
|         |             | `rhs` | integer or integer |  |  |

#### Results:

| Result | Description |
| :----: | ----------- |
|        |             |  | &laquo;unnamed&raquo; | integer or integer |  |  |  |

### `llhd.const` (llhd::ConstOp)

Introduce a new constant.

The `llhd.const` instruction introduces a new constant value as an
SSA-operator.
Legal types are integers and time. Note: Signals
are not legal to define using `llhd.const`, use the `llhd.sig`
instruction for that.

**Custom syntax:**

```
const-op ::= ssa-id `=` `llhd.const` attribute-value attr-dict `:` result-type
```

**Examples:**

```mlir
%0 = llhd.const 1 : i64
%1 = llhd.const #llhd.time<1ns, 2d, 3d> : !llhd.time
```

#### Attributes:

| Attribute | MLIR Type | Description   |
| :-------: | :-------: | ------------- |
|  `value`  | Attribute | any attribute |

#### Results:

| Result | Description               |
| :----: | ------------------------- |
| `out`  | integer or LLHD time type |

### `llhd.drv` (llhd::DrvOp)

Drive a value into a signal.

Syntax:

```
operation ::= `llhd.drv` operands attr-dict `:` type(operands)
```


The `llhd.drv` operation drives a new value onto a signal. A time operand
also has to be passed, which specifies the frequency at which the drive
will be performed. This operation does not define any new SSA operands.

**Custom Syntax:**

```
drv-op ::= `llhd.drv` ssa-signal `,` ssa-const `,` ssa-time `:` !llhd.sig<const-type> `,` const-type `,` time-type
```

**Examples:**

```mlir
%init = llhd.const 1 : i1
%time = llhd.const #llhd.time<1ns, 0d, 0e> : !llhd.time
%sig = llhd.sig %init : i1 -> !llhd.sig<i1>
%new = llhd.not %init : i1

llhd.drv %sig, %new, %time : !llhd.sig<i1>, i1, !llhd.time
```

#### Operands:

| Operand | Description               |
| :-----: | ------------------------- |
|         | `signal`                  | LLHD sig type |  |
| `value` | integer or LLHD time type |
| `time`  | LLHD time type            |

### `llhd.entity` (llhd::EntityOp)

Define an LLHD entity.


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
|           |   `ins`   | IntegerAttr | 64-bit signless integer attribute |  |

### `llhd.halt` (llhd::HaltOp)

Terminates execution of a process.

Syntax:

```
operation ::= `llhd.halt` attr-dict
```


The `halt` instruction terminates execution of a process. All processes
must halt eventually or consist of an infinite loop.
* This is a terminator instruction
* This instruction is only allowed in processes (`llhd.proc`).

**Syntax:**
```
halt-op ::= `llhd.halt`
```

**Examples:**
```
llhd.halt
```

### `llhd.neg` (llhd::NegOp)

Negate a value.

Syntax:

```
operation ::= `llhd.neg` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.neg(%value) : (T) -> T
```
* `T` must be `iN`
* `%value` is the input argument of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | integer     |

#### Results:

|                                                                       Result                                                                                 | Description |
| :----------------------------------------------------------------------------------------------------------------------------------------------------------: | ----------- |
| | | | | | | | | | &laquo;unnamed&raquo; | integer     |     |     |     |     |     |     |     |     |     |

### `llhd.not` (llhd::NotOp)

Bitwise NOT

Takes an integer of any width or a nine-valued-logic (IEEE 1164) value
of any width as input. Flips each bit of a value. The result always has
the exact same type.

**Syntax:**
```
not-op ::= ssa-id `=` `llhd.not` ssa-value attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.not %0 : i32
```

**Truth Table for `iN`:**

| `not` |   0   |   1   |
| :---: | :---: | :---: |
|       |   1   |   0   |

**Truth Table for `lN`:**

| `not` |   U   |   X   |   0   |   1   |   Z   |   W   |   L   |   H   |   -   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|       |   U   |   X   |   1   |   0   |   X   |   X   |   1   |   0   |   X   |

#### Operands:

| Operand | Description        |
| :-----: | ------------------ |
| `value` | integer or integer |

#### Results:

|                      Result                         | Description                      |
| :-------------------------------------------------: | -------------------------------- |
| | | &laquo;unnamed&raquo; | integer or integer | | |

### `llhd.or` (llhd::OrOp)

Bitwise OR

Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise OR. The
result is always of the exact same type as the two inputs.

**Syntax:**
```
or-op ::= ssa-id `=` `llhd.or` ssa-lhs `,` ssa-rhs attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.or %0, %0 : i32
```

**Truth Table for `iN`:**

| `or`  |   0   |   1   |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   1   |   0   |   1   |

**Truth Table for `lN`:**

| `or`  |   U   |   X   |   0   |   1   |   Z   |   W   |   L   |   H   |   -   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   U   |   U   |   U   |   U   |   1   |   U   |   U   |   U   |   1   |   U   |
|   X   |   U   |   X   |   X   |   1   |   X   |   X   |   X   |   1   |   X   |
|   0   |   U   |   X   |   0   |   1   |   X   |   X   |   0   |   1   |   X   |
|   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
|   Z   |   U   |   X   |   X   |   1   |   X   |   X   |   X   |   1   |   X   |
|   X   |   U   |   X   |   X   |   1   |   X   |   X   |   X   |   1   |   X   |
|   0   |   U   |   X   |   0   |   1   |   X   |   X   |   0   |   1   |   X   |
|   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
|   Z   |   U   |   X   |   X   |   1   |   X   |   X   |   X   |   1   |   X   |
|   W   |   U   |   X   |   X   |   1   |   X   |   X   |   X   |   1   |   X   |
|   L   |   U   |   X   |   0   |   1   |   X   |   X   |   0   |   1   |   X   |
|   H   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
|   -   |   U   |   X   |   X   |   1   |   X   |   X   |   X   |   1   |   X   |

#### Operands:

| Operand | Description               |
| :-----: | ------------------------- |
|  |  `lhs`   | integer or integer | |
|  |  `rhs`   | integer or integer | |

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer or integer

### `llhd.prb` (llhd::PrbOp)

Probe a signal.

Syntax:

```
operation ::= `llhd.prb` $signal attr-dict `:` type($signal) `->` type(results)
```


The `llhd.prb` instruction probes a signal and returns the value it
currently carries as a new SSA operand. The result type is always
the type carried by the signal.

 **Custom syntax:**

 ```
 prb-op ::= ssa-id `=` `llhd.prb` ssa-sig attr-dict `:` !llhd.sig<type> `->` type
 ```

 **Examples:**

 ```mlir
 %const_i1 = llhd.const 1 : i1
 %sig_i1 = llhd.sig %const_i1 : i1 -> !llhd.sig<i1>
 %prbd = llhd.prb %sig_i1 : !llhd.sig<i1> -> i1
 ```

#### Operands:

| Operand  | Description   |
| :------: | ------------- |
| `signal` | LLHD sig type |

#### Results:

|        Result         | Description               |
| :-------------------: | ------------------------- |
| &laquo;unnamed&raquo; | integer or LLHD time type |

### `llhd.proc` (llhd::ProcOp)




#### Attributes:

| Attribute |  MLIR Type  | Description                       |
| :-------: | :---------: | --------------------------------- |
|   `ins`   | IntegerAttr | 64-bit signless integer attribute |

### `llhd.sdiv` (llhd::SDivOp)

Signed division of two values.

Syntax:

```
operation ::= `llhd.sdiv` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.sdiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
|  |  |  |  |  |  |  |  |  `lhs`          | integer     |     |     |     |     |     |     |     |     |
|  |  |  |  |  |  |  |  |  `rhs`          | integer     |     |     |     |     |     |     |     |     |

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.smod` (llhd::SModOp)

Signed modulo of the signed division of two values.

Syntax:

```
operation ::= `llhd.smod` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.smod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.smul` (llhd::SMulOp)

Signed multiplication of two values.

Syntax:

```
operation ::= `llhd.smul` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.smul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.srem` (llhd::SRemOp)

Signed reminder of the signed division two values.
operation ::= `llhd.srem` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.srem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.shl` (llhd::ShlOp)

Shifts a value to the left by a given amount.

Syntax:

```
operation ::= `llhd.shl` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return
a signal to the shifted value.

```
%result = llhd.shl(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number
  of bits of elements.
* The maximum shift amount is determined by the number of bits or
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0,
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many
  positions the value is to be shifted. Must be of type `Ta`. Behavior
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

| Operand  | Description                         |
| :------: | ----------------------------------- |
|  `base`  | integer or integer or LLHD sig type |
| `hidden` | integer or integer or LLHD sig type |
| `amount` | integer                             |

#### Results:

| Result | Description |
| :----: | ----------- |
|        | `result`    | integer or integer or LLHD sig type |  |

### `llhd.shr` (llhd::ShrOp)

Shifts a value to the right by a given amount.

Syntax:

```
operation ::= `llhd.shr` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return
a signal to the shifted value.

```
%result = llhd.shr(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number
  of bits of elements.
* The maximum shift amount is determined by the number of bits or
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0,
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many
  positions the value is to be shifted. Must be of type `Ta`. Behavior
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

| Operand  | Description                         |
| :------: | ----------------------------------- |
|  `base`  | integer or integer or LLHD sig type |
| `hidden` | integer or integer or LLHD sig type |
| `amount` | signless integer                    |

#### Results:

|  Result  | Description                         |
| :------: | ----------------------------------- |
| `result` | integer or integer or LLHD sig type |

### `llhd.sig` (llhd::SigOp)

Create a signal.

Syntax:

```
operation ::= `llhd.sig` $init attr-dict `:` type($init) `->` type(results)
```


The `llhd.sig` instruction introduces a new signal in the IR. The input
operand determines the initial value carried by the signal, while the
result type will always be a signal carrying the type of the init operand.

**Custom syntax:**

```
sig-op ::= ssa-id `=` `llhd.sig` ssa-init attr-dict `:` init-type `->` !llhd.sig<init-type>
```

**Examples:**

```mlir
%init_i64 = llhd.const 123 : i64
%sig_i64 = llhd.sig %init_64 : i64 -> !llhd.sig<i64>

%init_i1 = llhd.const 1 : i1
%sig_i1 = llhd.sig %init_i1 : i1 -> !llhd.sig<i1>
```
The first `llhd.sig` instruction creates a new signal carrying an `i64`
type with initial value of 123, while the second one creates a new signal
carrying an `i1` value with initial value of 1.

#### Operands:

| Operand | Description               |
| :-----: | ------------------------- |
| `init`  | integer or LLHD time type |

#### Results:

|        Result         | Description   |
| :-------------------: | ------------- |
| &laquo;unnamed&raquo; | LLHD sig type |

### `llhd.sub` (llhd::SubOp)

Subtract two values.

Syntax:

```
operation ::= `llhd.sub` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.sub(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.terminator` (llhd::TerminatorOp)

Dummy terminator


### `llhd.udiv` (llhd::UDivOp)

Unsigned division of two values.

Syntax:

```
operation ::= `llhd.udiv` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.udiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.umod` (llhd::UModOp)

Unsigned modulo of the unsigned division of two values.

Syntax:

```
operation ::= `llhd.umod` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.umod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.umul` (llhd::UMulOp)

Unsigned multiplication of two values.

Syntax:

```
operation ::= `llhd.umul` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.umul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.urem` (llhd::URemOp)

Unsigned reminder of the unsigned division two values.

Syntax:

```
operation ::= `llhd.urem` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.urem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.wait` (llhd::WaitOp)

Suspends execution of a process.

The `wait` instruction suspends execution of a process until any of the
observed signals change or a fixed time interval has passed. Execution
resumes at the specified basic block with the passed arguments.
* This is a terminator instruction.
* This instruction is only allowed in processes (`llhd.proc`).

**Syntax:**
```
wait-op ::= `llhd.wait` ssa-list-obs (`for` ssa-time)? `,` successor-dest ( `(` ssa-list-dest-arguments `:` type-list-dest-arguments `)` )? `:` type-list-obs (`,` type-time)?
```
Notes:
* `ssa-list-obs`, `ssa-list-dest-arguments`, `type-list-dest-arguments` and `type-list-obs` are comma-separated lists of 0 or more elements.
* In case there is no optional time and `type-list-obs` has zero elements, the last colon is omitted as well.

**Examples:**
```
llhd.wait ^bb1
llhd.wait for %time, ^bb1(%time : !llhd.time) : !llhd.time
llhd.wait %0, %1, ^bb1(%1 : !llhd.sig<i1>) : !llhd.sig<i64>, !llhd.sig<i1>
llhd.wait %0, %1 for %time, ^bb1(%1, %0 : !llhd.sig<i1>, !llhd.sig<i64>) : !llhd.sig<i64>, !llhd.sig<i1>, !llhd.time
```

#### Attributes:

|        Attribute        |      MLIR Type       | Description                                |
| :---------------------: | :------------------: | ------------------------------------------ |
| `operand_segment_sizes` | DenseIntElementsAttr | 32-bit signless integer elements attribute |

#### Operands:

|  Operand  | Description    |
| :-------: | -------------- |
|   `obs`   | LLHD sig type  |
|  `time`   | LLHD time type |
| `destOps` | any type       |

#### Successors:

| Successor | Description   |
| :-------: | ------------- |
|  `dest`   | any successor |

### `llhd.xor` (llhd::XorOp)

Bitwise XOR

Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise XOR. The
result is always of the exact same type as the two inputs.

**Syntax:**
```
xor-op ::= ssa-id `=` `llhd.xor` ssa-lhs `,` ssa-rhs attr-dict `:` type
```

**Examples:**
```
%0 = llhd.const 0 : i32
%1 = llhd.xor %0, %0 : i32
```

**Truth Table for `iN`:**

| `xor` |   0   |   1   |
| :---: | :---: | :---: |
|   0   |   0   |   0   |
|   1   |   0   |   1   |

**Truth Table for `lN`:**

| `xor` |   U   |   X   |   0   |   1   |   Z   |   W   |   L   |   H   |   -   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   U   |   U   |   U   |   U   |   U   |   U   |   U   |   U   |   U   |   U   |
|   X   |   U   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |
|   0   |   U   |   X   |   0   |   1   |   X   |   X   |   0   |   1   |   X   |
|   1   |   U   |   X   |   1   |   0   |   X   |   X   |   1   |   0   |   X   |
|   Z   |   U   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |
|   W   |   U   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |
|   L   |   U   |   X   |   0   |   1   |   X   |   X   |   0   |   1   |   X   |
|   H   |   U   |   X   |   1   |   0   |   X   |   X   |   1   |   0   |   X   |
|   -   |   U   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |   X   |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer or integer
`rhs` | integer or integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer or integer

