---
layout: default
name: LLHD Documentation
---
<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# Dialect 'llhd' definition


A low-level hardware description dialect in MLIR.

[TOC]

## Operation definition

### llhd.add (llhd::AddOp)
Add two values.

#### Description:


```
%result = llhd.add(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.and (llhd::AndOp)
Computes the bitwise AND of two values.

#### Description:


```
%result = llhd.and(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `and` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `and` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  0  |  U  |  U  |  U  |  0  |  U  |  U  |
|   X   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   0   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   1   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   Z   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   W   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   L   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   H   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   -   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |

#### Operands:

1. `lhs`: integer or integer
1. `rhs`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

### llhd.const (llhd::ConstOp)
Introduce a new constant.

#### Description:


The `llhd.const` instruction introduces a new constant value as an 
SSA-operator.  
Legal types are integers and time. Note: Signals 
are not legal to define using `llhd.const`, use the `llhd.sig` 
instruction for that.

**Custom syntax:**

```
const-op ::= <ssa-id> `=` `llhd.const` attr-dict <attribute-value> `:` <result-type>
```

**Examples:**

```mlir
%0 = llhd.const 1 : i64
%1 = llhd.const #llhd.time<1ns, 2d, 3d> : !llhd.time
```

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | `Attribute` | any attribute attribute |

#### Results:

1. `out`: integer or LLHD time type

### llhd.drv (llhd::DrvOp)
Drive a value into a signal.

#### Description:


The `llhd.drv` operation drives a new value onto a signal. A time operand
also has to be passed, which specifies the frequency at which the drive
will be performed. This operation does not define any new SSA operands.

**Custom Syntax:**

```
drv-op ::= `llhd.drv` <ssa-signal>`,` <ssa-const>`,` <ssa-time> `:` !llhd.sig< <const-type> >`,` <const-type>`,` <time-type>
```

**Examples:**

```mlir
%init = llhd.const 1 : i1
%time = llhd.const #llhd.time<1ns, 0d, 0e> : !llhd.time
%sig = llhd.sig %init : i1 -> !llhd.sig<i1>
%new = llhd.not %init : i1

llhd.drv %sig, %new, %time : !llhd.sig<i1>, i1, !llhd.time
```

#### Operands:

1. `signal`: LLHD sig type
1. `value`: integer or LLHD time type
1. `time`: LLHD time type

#### Attributes:


#### Results:


### llhd.entity (llhd::EntityOp)
Define an LLHD entity.

#### Description:



#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ins` | `IntegerAttr` | 64-bit signless integer attribute attribute |

#### Results:


### llhd.halt (llhd::HaltOp)
Terminates execution of a process.

#### Description:


The `halt` instruction terminates execution of a process. All processes 
must eventually halt or consist of an infinite loop.
* This is a terminator instruction

#### Operands:


#### Attributes:


#### Results:


### llhd.neg (llhd::NegOp)
Negate a value.

#### Description:


```
%result = llhd.neg(%value) : (T) -> T
```
* `T` must be `iN`
* `%value` is the input argument of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `value`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.not (llhd::NotOp)
Flips each bit of a value.

#### Description:


```
%result = llhd.not(%value) : (T) -> T
```
* `T` must be `iN` or `lN`.
* `%value` is the input argument of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `not` |  0  |  1  |
|:-----:|:---:|:---:|
|       |  1  |  0  |

Truth Table for `lN`:

| `not` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|       |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |

#### Operands:

1. `value`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

### llhd.or (llhd::OrOp)
Computes the bitwise OR of two values.

#### Description:


```
%result = llhd.or(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `or`  |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `or`  |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  1  |  U  |  U  |  U  |  1  |  U  |
|   X   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   Z   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   W   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   -   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |

#### Operands:

1. `lhs`: integer or integer
1. `rhs`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

### llhd.prb (llhd::PrbOp)
Probe a signal.

#### Description:


The `llhd.prb` instruction probes a signal and returns the value it
currently carries as a new SSA operand. The result type is always
the type carried by the signal.

 **Custom syntax:**

 ```
 prb-op ::= <ssa-id> `=` `llhd.prb` <ssa-use> attr-dict `:` !llhd.sig< <type> > `->` <type>
 ```

 **Examples:***

 ```mlir
 %const_i1 = llhd.const 1 : i1
 %sig_i1 = llhd.sig %const_i1 : i1 -> !llhd.sig<i1>
 %prbd = llhd.prb %sig_i1 : !llhd.sig<i1> -> i1
 ```

#### Operands:

1. `signal`: LLHD sig type

#### Attributes:


#### Results:

1. `output`: integer or LLHD time type

### llhd.proc (llhd::ProcOp)


#### Description:



#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ins` | `IntegerAttr` | 64-bit signless integer attribute attribute |

#### Results:


### llhd.sdiv (llhd::SDivOp)
Signed division of two values.

#### Description:


```
%result = llhd.sdiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.smod (llhd::SModOp)
Signed modulo of the signed division of two values.

#### Description:


```
%result = llhd.smod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.smul (llhd::SMulOp)
Signed multiplication of two values.

#### Description:


```
%result = llhd.smul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.srem (llhd::SRemOp)
Signed reminder of the signed division two values.

#### Description:


```
%result = llhd.srem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.shl (llhd::ShlOp)
Shifts a value to the left by a given amount.

#### Description:


The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.

```
%result = llhd.shl(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number 
  of bits of elements.
* The maximum shift amount is determined by the number of bits or 
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0, 
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift 
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many 
  positions the value is to be shifted. Must be of type `Ta`. Behavior 
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

1. `base`: integer or integer or LLHD sig type
1. `hidden`: integer or integer or LLHD sig type
1. `amount`: integer

#### Attributes:


#### Results:

1. `result`: integer or integer or LLHD sig type

### llhd.shr (llhd::ShrOp)
Shifts a value to the right by a given amount.

#### Description:


The instruction is transparent to signals and pointers. For example, 
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.

```
%result = llhd.shr(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number 
  of bits of elements.
* The maximum shift amount is determined by the number of bits or 
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0, 
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift 
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many 
  positions the value is to be shifted. Must be of type `Ta`. Behavior 
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

1. `base`: integer or integer or LLHD sig type
1. `hidden`: integer or integer or LLHD sig type
1. `amount`: signless integer

#### Attributes:


#### Results:

1. `result`: integer or integer or LLHD sig type

### llhd.sig (llhd::SigOp)
Create a signal.

#### Description:


The `llhd.sig` instruction introduces a new signal in the IR. The input 
operand determines the initial value carried by the signal, while the
result type will always be a signal carrying the type of the init operand.

**Custom syntax:**

```
sig-op ::= <ssa-id> `=` `llhd.sig` <ssa-use> attr-dict `:` <init-type> `->` !llhd.sig< <init-type> >
```

**Examples:**

```mlir
%init_i64 = llhd.const 123 : i64
%sig_i64 = llhd.sig %init_64 : i64 -> !llhd.sig<i64>

%init_i1 = llhd.const 1 : i1
%sig_i1 = llhd.sig %init_i1 : i1 -> !llhd.sig<i1>
```
The first `llhd.sig` instruction creates a new signal carrying an `i64` 
type with initial value of 123, while the second one creates a new signal
carrying an `i1` value with initial value of 1.

#### Operands:

1. `init`: integer or LLHD time type

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: LLHD sig type

### llhd.sub (llhd::SubOp)
Subtract two values.

#### Description:


```
%result = llhd.sub(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.terminator (llhd::TerminatorOp)
Dummy terminator

#### Description:



#### Operands:


#### Attributes:


#### Results:


### llhd.udiv (llhd::UDivOp)
Unsigned division of two values.

#### Description:


```
%result = llhd.udiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.umod (llhd::UModOp)
Unsigned modulo of the unsigned division of two values.

#### Description:


```
%result = llhd.umod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.umul (llhd::UMulOp)
Unsigned multiplication of two values.

#### Description:


```
%result = llhd.umul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.urem (llhd::URemOp)
Unsigned reminder of the unsigned division two values.

#### Description:


```
%result = llhd.urem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.wait (llhd::WaitOp)
Suspends execution of a process.

#### Description:


The `wait` instruction suspends execution of a process until any of the 
observed signals change or optionally a fixed time interval has passed.

#### Operands:

1. `obs`: LLHD sig type
1. `destOps`: integer or LLHD sig type or LLHD time type

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `operand_segment_sizes` | `DenseIntElementsAttr` | 32-bit signless integer elements attribute attribute |

#### Results:


### llhd.xor (llhd::XorOp)
Computes the bitwise XOR of two values.

#### Description:


```
%result = llhd.xor(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `xor` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `xor` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |
|   X   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   Z   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   W   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   -   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |

#### Operands:

1. `lhs`: integer or integer
1. `rhs`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

