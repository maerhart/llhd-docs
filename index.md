---
layout: default
name: LLHD Documentation
---
<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# Dialect 'llhd' definition


A low-level hardware description dialect in MLIR.

[TOC]

## Operation definition

### llhd.add (llhd::AddOp)
Add two values.

#### Description:


```
%result = llhd.add(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.and (llhd::AndOp)
Computes the bitwise AND of two values.

#### Description:


```
%result = llhd.and(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `and` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `and` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  0  |  U  |  U  |  U  |  0  |  U  |  U  |
|   X   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   0   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   1   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   Z   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   W   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   L   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   H   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   -   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |

#### Operands:

1. `lhs`: integer or integer
1. `rhs`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

### llhd.const (llhd::ConstOp)
Constant

#### Description:


The const instruction is used to introduce a constant value into the IR. 
The first version constructs a constant integer value, the second a 
constant integer signal, and the third a constant time value.
```
%result = llhd.const <int> : iN
%result = llhd.const <int> : !llhd.sig<iN>
%result = llhd.const <time> : time
```
`int` is an integer literal such as `0b0101`, `0o1247`, `129`, or `0x14F3E`
time is a time literal such as `1s`, `1s 2d`, or `1s 2d 3e`, where the 
real component may carry an SI prefix such as `as`, `fs`, `ps`, `ns`, 
`us`, `ms`.

#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | `IntegerAttr` | 64-bit signless integer attribute attribute |

#### Results:

1. `out`: integer or LLHD sig type

### llhd.drv (llhd::DrvOp)
Drive a value into a signal.

#### Description:


```
drv T$ %sig, %value
```
The drv instruction drives a `%value` onto a signal `%sig`.

* `T` may be any type.
* `%sig` must be of type `T$`.
* `%value` must be of type `T`.

#### Operands:

1. `signal`: LLHD sig type
1. `value`: integer

#### Attributes:


#### Results:


### llhd.entity (llhd::EntityOp)
Define an LLHD entity.

#### Description:



#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ins` | `IntegerAttr` | 64-bit signless integer attribute attribute |

#### Results:


### llhd.halt (llhd::HaltOp)
Terminates execution of a process.

#### Description:


The `halt` instruction terminates execution of a process. All processes 
must eventually halt or consist of an infinite loop.
* This is a terminator instruction

#### Operands:


#### Attributes:


#### Results:


### llhd.neg (llhd::NegOp)
Negate a value.

#### Description:


```
%result = llhd.neg(%value) : (T) -> T
```
* `T` must be `iN`
* `%value` is the input argument of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `value`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.not (llhd::NotOp)
Flips each bit of a value.

#### Description:


```
%result = llhd.not(%value) : (T) -> T
```
* `T` must be `iN` or `lN`.
* `%value` is the input argument of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `not` |  0  |  1  |
|:-----:|:---:|:---:|
|       |  1  |  0  |

Truth Table for `lN`:

| `not` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|       |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |

#### Operands:

1. `value`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

### llhd.or (llhd::OrOp)
Computes the bitwise OR of two values.

#### Description:


```
%result = llhd.or(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `or`  |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `or`  |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  1  |  U  |  U  |  U  |  1  |  U  |
|   X   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   Z   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   W   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   -   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |

#### Operands:

1. `lhs`: integer or integer
1. `rhs`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

### llhd.prb (llhd::PrbOp)
Probe a signal.

#### Description:


```
%result = prb T$ %sig
```
The `prb` instruction probes the current value of a signal `%sig`.

* `T` may be any type.
* `%sig` must be of type `T$`.
* `%result` is of type `T`.

#### Operands:

1. `signal`: LLHD sig type

#### Attributes:


#### Results:

1. `output`: integer

### llhd.proc (llhd::ProcOp)


#### Description:



#### Operands:


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ins` | `IntegerAttr` | 64-bit signless integer attribute attribute |

#### Results:


### llhd.sdiv (llhd::SDivOp)
Signed division of two values.

#### Description:


```
%result = llhd.sdiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.smod (llhd::SModOp)
Signed modulo of the signed division of two values.

#### Description:


```
%result = llhd.smod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.smul (llhd::SMulOp)
Signed multiplication of two values.

#### Description:


```
%result = llhd.smul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.srem (llhd::SRemOp)
Signed reminder of the signed division two values.

#### Description:


```
%result = llhd.srem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.shl (llhd::ShlOp)
Shifts a value to the left by a given amount.

#### Description:


The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.

```
%result = llhd.shl(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number 
  of bits of elements.
* The maximum shift amount is determined by the number of bits or 
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0, 
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift 
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many 
  positions the value is to be shifted. Must be of type `Ta`. Behavior 
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

1. `base`: integer or integer or LLHD sig type
1. `hidden`: integer or integer or LLHD sig type
1. `amount`: integer

#### Attributes:


#### Results:

1. `result`: integer or integer or LLHD sig type

### llhd.shr (llhd::ShrOp)
Shifts a value to the right by a given amount.

#### Description:


The instruction is transparent to signals and pointers. For example, 
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.

```
%result = llhd.shr(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number 
  of bits of elements.
* The maximum shift amount is determined by the number of bits or 
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0, 
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift 
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many 
  positions the value is to be shifted. Must be of type `Ta`. Behavior 
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

1. `base`: integer or integer or LLHD sig type
1. `hidden`: integer or integer or LLHD sig type
1. `amount`: signless integer

#### Attributes:


#### Results:

1. `result`: integer or integer or LLHD sig type

### llhd.sig (llhd::SigOp)
Create a signal.

#### Description:


```
%result = llhd.sig %init : T
```

The `sig` instruction creates a signal in an entity with the initial 
value `%init` and returns that signal.

* `T` may be any type.  
* `%init` is the initial value of the signal and must be of type `T`.  
* `%result` is of type `T$`.  

#### Operands:

1. `init`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: LLHD sig type

### llhd.sub (llhd::SubOp)
Subtract two values.

#### Description:


```
%result = llhd.sub(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.terminator (llhd::TerminatorOp)
Dummy terminator

#### Description:



#### Operands:


#### Attributes:


#### Results:


### llhd.udiv (llhd::UDivOp)
Unsigned division of two values.

#### Description:


```
%result = llhd.udiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.umod (llhd::UModOp)
Unsigned modulo of the unsigned division of two values.

#### Description:


```
%result = llhd.umod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.umul (llhd::UMulOp)
Unsigned multiplication of two values.

#### Description:


```
%result = llhd.umul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.urem (llhd::URemOp)
Unsigned reminder of the unsigned division two values.

#### Description:


```
%result = llhd.urem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

1. `lhs`: integer
1. `rhs`: integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer

### llhd.wait (llhd::WaitOp)
Suspends execution of a process.

#### Description:


The `wait` instruction suspends execution of a process until any of the 
observed signals change or optionally a fixed time interval has passed.

#### Operands:

1. `obs`: LLHD sig type
1. `destOps`: integer or LLHD sig type

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `operand_segment_sizes` | `DenseIntElementsAttr` | 32-bit signless integer elements attribute attribute |

#### Results:


### llhd.xor (llhd::XorOp)
Computes the bitwise XOR of two values.

#### Description:


```
%result = llhd.xor(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `xor` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `xor` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |
|   X   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   Z   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   W   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   -   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |

#### Operands:

1. `lhs`: integer or integer
1. `rhs`: integer or integer

#### Attributes:


#### Results:

1. &laquo;unnamed&raquo;: integer or integer

