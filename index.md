---
layout: default
name: LLHD Documentation
---
<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `llhd.add` (llhd::AddOp)

Add two values.

Syntax:

```
operation ::= `llhd.add` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.add(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.and` (llhd::AndOp)

Computes the bitwise AND of two values.

Syntax:

```
operation ::= `llhd.and` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.and(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `and` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `and` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  0  |  U  |  U  |  U  |  0  |  U  |  U  |
|   X   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   0   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   1   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   Z   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   W   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |
|   L   |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|   H   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   -   |  U  |  X  |  0  |  X  |  X  |  X  |  0  |  X  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer or integer
`rhs` | integer or integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer or integer

### `llhd.const` (llhd::ConstOp)

Introduce a new constant.

The `llhd.const` instruction introduces a new constant value as an 
SSA-operator.  
Legal types are integers and time. Note: Signals 
are not legal to define using `llhd.const`, use the `llhd.sig` 
instruction for that.

**Custom syntax:**

```
const-op ::= <ssa-id> `=` `llhd.const` attr-dict <attribute-value> `:` <result-type>
```

**Examples:**

```mlir
%0 = llhd.const 1 : i64
%1 = llhd.const #llhd.time<1ns, 2d, 3d> : !llhd.time
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`value` | Attribute | any attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`out` | integer or LLHD time type

### `llhd.drv` (llhd::DrvOp)

Drive a value into a signal.

Syntax:

```
operation ::= `llhd.drv` operands attr-dict `:` type(operands)
```


The `llhd.drv` operation drives a new value onto a signal. A time operand
also has to be passed, which specifies the frequency at which the drive
will be performed. This operation does not define any new SSA operands.

**Custom Syntax:**

```
drv-op ::= `llhd.drv` ssa-signal `,` ssa-const `,` ssa-time `:` !llhd.sig<const-type> `,` const-type `,` time-type
```

**Examples:**

```mlir
%init = llhd.const 1 : i1
%time = llhd.const #llhd.time<1ns, 0d, 0e> : !llhd.time
%sig = llhd.sig %init : i1 -> !llhd.sig<i1>
%new = llhd.not %init : i1

llhd.drv %sig, %new, %time : !llhd.sig<i1>, i1, !llhd.time
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`signal` | LLHD sig type
`value` | integer or LLHD time type
`time` | LLHD time type

### `llhd.entity` (llhd::EntityOp)

Define an LLHD entity.


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`ins` | IntegerAttr | 64-bit signless integer attribute

### `llhd.halt` (llhd::HaltOp)

Terminates execution of a process.

Syntax:

```
operation ::= `llhd.halt` attr-dict
```


The `halt` instruction terminates execution of a process. All processes 
must eventually halt or consist of an infinite loop.
* This is a terminator instruction

### `llhd.neg` (llhd::NegOp)

Negate a value.

Syntax:

```
operation ::= `llhd.neg` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.neg(%value) : (T) -> T
```
* `T` must be `iN`
* `%value` is the input argument of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.not` (llhd::NotOp)

Flips each bit of a value.

Syntax:

```
operation ::= `llhd.not` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.not(%value) : (T) -> T
```
* `T` must be `iN` or `lN`.
* `%value` is the input argument of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `not` |  0  |  1  |
|:-----:|:---:|:---:|
|       |  1  |  0  |

Truth Table for `lN`:

| `not` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|       |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | integer or integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer or integer

### `llhd.or` (llhd::OrOp)

Computes the bitwise OR of two values.

Syntax:

```
operation ::= `llhd.or` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.or(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `or`  |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `or`  |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  1  |  U  |  U  |  U  |  1  |  U  |
|   X   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   Z   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   W   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
|   -   |  U  |  X  |  X  |  1  |  X  |  X  |  X  |  1  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer or integer
`rhs` | integer or integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer or integer

### `llhd.prb` (llhd::PrbOp)

Probe a signal.

Syntax:

```
operation ::= `llhd.prb` $signal attr-dict `:` type($signal) `->` type(results)
```


The `llhd.prb` instruction probes a signal and returns the value it
currently carries as a new SSA operand. The result type is always
the type carried by the signal.

 **Custom syntax:**

 ```
 prb-op ::= ssa-id `=` `llhd.prb` ssa-sig attr-dict `:` !llhd.sig<type> `->` type
 ```

 **Examples:***

 ```mlir
 %const_i1 = llhd.const 1 : i1
 %sig_i1 = llhd.sig %const_i1 : i1 -> !llhd.sig<i1>
 %prbd = llhd.prb %sig_i1 : !llhd.sig<i1> -> i1
 ```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`signal` | LLHD sig type

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer or LLHD time type

### `llhd.proc` (llhd::ProcOp)




#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`ins` | IntegerAttr | 64-bit signless integer attribute

### `llhd.sdiv` (llhd::SDivOp)

Signed division of two values.

Syntax:

```
operation ::= `llhd.sdiv` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.sdiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.smod` (llhd::SModOp)

Signed modulo of the signed division of two values.

Syntax:

```
operation ::= `llhd.smod` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.smod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.smul` (llhd::SMulOp)

Signed multiplication of two values.

Syntax:

```
operation ::= `llhd.smul` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.smul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.srem` (llhd::SRemOp)

Signed reminder of the signed division two values.

Syntax:

```
operation ::= `llhd.srem` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.srem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.shl` (llhd::ShlOp)

Shifts a value to the left by a given amount.

Syntax:

```
operation ::= `llhd.shl` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.

```
%result = llhd.shl(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number 
  of bits of elements.
* The maximum shift amount is determined by the number of bits or 
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0, 
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift 
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many 
  positions the value is to be shifted. Must be of type `Ta`. Behavior 
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`base` | integer or integer or LLHD sig type
`hidden` | integer or integer or LLHD sig type
`amount` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | integer or integer or LLHD sig type

### `llhd.shr` (llhd::ShrOp)

Shifts a value to the right by a given amount.

Syntax:

```
operation ::= `llhd.shr` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


The instruction is transparent to signals and pointers. For example, 
passing a signal as argument will shift the underlying value and return 
a signal to the shifted value.

```
%result = llhd.shr(%base, %hidden, %amount) : (T, Th, Ta) -> T
```
* `T` must be `iN` or `lN`, or an array; or a signal/pointer thereof.
* `Th` must be of the same type as T, but may have a different number 
  of bits of elements.
* The maximum shift amount is determined by the number of bits or 
  elements in `Th`.
* `Ta` must be `iN`.
* `%base` is the base value that is produced if the shift amount is 0, 
  and must be of type `T`.
* `%hidden` is the hidden value that is uncovered by non-zero shift 
  amounts, and must be of type `Th`.
* `%amount` is the unsigned shift amount and determines by how many 
  positions the value is to be shifted. Must be of type `Ta`. Behavior 
  for values `%amount > N` is undefined.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`base` | integer or integer or LLHD sig type
`hidden` | integer or integer or LLHD sig type
`amount` | signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | integer or integer or LLHD sig type

### `llhd.sig` (llhd::SigOp)

Create a signal.

Syntax:

```
operation ::= `llhd.sig` $init attr-dict `:` type($init) `->` type(results)
```


The `llhd.sig` instruction introduces a new signal in the IR. The input 
operand determines the initial value carried by the signal, while the
result type will always be a signal carrying the type of the init operand.

**Custom syntax:**

```
sig-op ::= ssa-id `=` `llhd.sig` ssa-init attr-dict `:` init-type `->` !llhd.sig<init-type>
```

**Examples:**

```mlir
%init_i64 = llhd.const 123 : i64
%sig_i64 = llhd.sig %init_64 : i64 -> !llhd.sig<i64>

%init_i1 = llhd.const 1 : i1
%sig_i1 = llhd.sig %init_i1 : i1 -> !llhd.sig<i1>
```
The first `llhd.sig` instruction creates a new signal carrying an `i64` 
type with initial value of 123, while the second one creates a new signal
carrying an `i1` value with initial value of 1.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`init` | integer or LLHD time type

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | LLHD sig type

### `llhd.sub` (llhd::SubOp)

Subtract two values.

Syntax:

```
operation ::= `llhd.sub` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.sub(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.terminator` (llhd::TerminatorOp)

Dummy terminator


### `llhd.udiv` (llhd::UDivOp)

Unsigned division of two values.

Syntax:

```
operation ::= `llhd.udiv` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.udiv(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.umod` (llhd::UModOp)

Unsigned modulo of the unsigned division of two values.

Syntax:

```
operation ::= `llhd.umod` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.umod(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.umul` (llhd::UMulOp)

Unsigned multiplication of two values.

Syntax:

```
operation ::= `llhd.umul` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.umul(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.urem` (llhd::URemOp)

Unsigned reminder of the unsigned division two values.

Syntax:

```
operation ::= `llhd.urem` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.urem(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN`
* `%lhs` and `%rhs` are the left- and right-hand side arguments and must be of type `T`.
* `%result` is of type `T`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer
`rhs` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer

### `llhd.wait` (llhd::WaitOp)

Suspends execution of a process.

The `wait` instruction suspends execution of a process until any of the 
observed signals change or optionally a fixed time interval has passed.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`operand_segment_sizes` | DenseIntElementsAttr | 32-bit signless integer elements attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`obs` | LLHD sig type
`destOps` | integer or LLHD sig type or LLHD time type

#### Successors:

| Successor | Description |
| :-------: | ----------- |
`dest` | any successor

### `llhd.xor` (llhd::XorOp)

Computes the bitwise XOR of two values.

Syntax:

```
operation ::= `llhd.xor` `(` operands `)` attr-dict `:` `(` type(operands) `)` `->` type(results)
```


```
%result = llhd.xor(%lhs, %rhs) : (T, T) -> T
```
* `T` must be `iN` or `lN`.
* `%lhs` and `%rhs` are the input arguments of type `T`.
* `%result` is of type `T`.

Truth Table for `iN`:

| `xor` |  0  |  1  |
|:-----:|:---:|:---:|
|   0   |  0  |  0  |
|   1   |  0  |  1  |

Truth Table for `lN`:

| `xor` |  U  |  X  |  0  |  1  |  Z  |  W  |  L  |  H  |  -  |
|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|   U   |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |  U  |
|   X   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   0   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   1   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   Z   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   W   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |
|   L   |  U  |  X  |  0  |  1  |  X  |  X  |  0  |  1  |  X  |
|   H   |  U  |  X  |  1  |  0  |  X  |  X  |  1  |  0  |  X  |
|   -   |  U  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |  X  |

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | integer or integer
`rhs` | integer or integer

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | integer or integer

